Архитектурная спецификация и план реализации скриптов Tier 3 (The View) для Mnemosyne Core
1. Введение: Стратегическая роль уровня представления в парадигме локального цифрового двойника
Проект Mnemosyne Core, определенный в технической документации как «Локальный цифровой двойник» (Local Digital Twin), представляет собой сложную инженерную систему, функционирующую на базе трехуровневой полиглот-архитектуры.1 В то время как низкоуровневый сбор данных (Tier 1: The Watcher) и семантическая обработка (Tier 2: The Brain) обеспечивают фундамент системы, именно Tier 3: The View, реализованный на JavaScript в среде Obsidian, является критически важным интерфейсом взаимодействия человека и машины. Этот уровень не просто визуализирует данные, но служит инструментом когнитивного усиления, реализуя концепцию «Активного воспоминания» (Recall Interface) и замыкая цикл обучения системы через механизмы обратной связи (RLHF — Reinforcement Learning from Human Feedback).1
В соответствии с мандатом Внутреннего технического директора (Internal CTO), архитектура перешла от академического прототипа к прагматичной модели V3.0, где приоритет отдается детерминированным сигналам и локальной обработке данных.1 Реализация Tier 3 должна строго соответствовать ограничениям на использование ресурсов (нулевое влияние на производительность хоста) и требованиям абсолютной приватности, исключая передачу данных во внешние облачные API.2
Данный отчет представляет собой исчерпывающее техническое руководство по реализации скриптов JavaScript, определяющее архитектуру, логику модулей, протоколы взаимодействия с файловой системой и стратегии рендеринга данных в рамках экосистемы Obsidian.
2. Архитектурные принципы и среда исполнения (Runtime Environment)
2.1. Концепция "View as a Query" и ограничения платформы
Среда исполнения Tier 3 — это Obsidian, приложение на базе Electron, предоставляющее доступ к Node.js API и локальной файловой системе.3 Однако, в отличие от стандартных веб-приложений, Mnemosyne Core Tier 3 не имеет выделенного бэкенда для UI. Он функционирует в парадигме «Представление как запрос» (View as a Query).
Данные, генерируемые слоями Go и Python, сохраняются в базе данных SQLite и частично дублируются/экспортируются в Markdown-файлы (Daily Logs).1 Скрипты JavaScript не хранят состояние; они являются эфемерными проекциями, которые динамически реконструируют состояние системы из персистентного хранилища в момент обращения пользователя.
Ключевые архитектурные ограничения:
    1. Однопоточность UI: JavaScript в Obsidian выполняется в основном потоке рендеринга. Любые синхронные операции ввода-вывода (I/O) или тяжелые вычисления заблокируют интерфейс пользователя, что недопустимо.2 Использование async/await и микро-задач является обязательным стандартом.
    2. Песочница и безопасность: Несмотря на локальное исполнение, скрипты должны следовать принципу наименьших привилегий. Прямое использование модулей Node.js (fs, child_process) допускается только через абстракции Obsidian API (app.vault, app.fileManager), чтобы гарантировать целостность индекса файлов приложения.3
    3. Изоляция зависимостей: Архитектура запрещает написание монолитных блоков кода внутри заметок (dataviewjs codeblocks). Вся логика должна быть вынесена в модульные файлы .js, загружаемые через механизм dv.view(). Это обеспечивает версионирование, повторное использование кода и упрощает отладку.5
2.2. Стек технологий Tier 3
На основании анализа доступных инструментов и требований к производительности 2, утвержден следующий технологический стек для уровня представления:

Компонент	Технология / Библиотека	Роль в архитектуре
Core Engine	Obsidian DataviewJS	Основной движок запросов и рендеринга. Предоставляет доступ к индексу метаданных vault и API рендеринга HTML.
Logic Layer	Vanilla JavaScript (ES6+)	Реализация бизнес-логики, обработки данных и управления состоянием интерфейса.
Visualization	Mermaid.js	Динамическая генерация диаграмм Ганта (Gantt Charts) и sequence-диаграмм для визуализации хронологии событий.9
Visualization	Obsidian Charts (Chart.js)	(Опционально) Построение круговых диаграмм и тепловых карт (Heatmaps) распределения активности.11
Integration	Obsidian API	Взаимодействие с файловой системой (чтение/запись), управление окнами и модальными диалогами.3
3. Модульная Архитектура Скриптов (Script Architecture)
Для обеспечения масштабируемости и поддерживаемости, кодовая база Tier 3 разделена на четыре функциональных модуля. Каждый модуль инкапсулирует специфическую область ответственности и предоставляет публичный API для других компонентов.
3.1. Модуль A: Data Ingestion & Abstraction (Слой абстракции данных)
Имя файла: mnemosyne_data_connector.js
Этот модуль служит единственной точкой входа для получения данных. Он изолирует логику визуализации от физического формата хранения данных (Markdown Frontmatter, JSON-файлы или SQLite). Это критически важно для будущей миграции: если в версии V4.0 будет решено читать данные напрямую из SQLite через WASM, потребуется переписать только этот модуль.13
Функциональные обязанности:
    1. Агрегация логов: Сбор фрагментированных записей активности (например, если Python-скрипт разбивает логи по часам) в единый массив событий за день.
    2. Нормализация данных: Приведение разнородных форматов метаданных к единой схеме (например, гарантия наличия полей timestamp, app_name, intent).
    3. Кэширование: Реализация механизма мемоизации для предотвращения повторного чтения файлов при переключении вкладок интерфейса.
Спецификация интерфейса (API Contract):

JavaScript


class MnemosyneData {
    /**
     * Возвращает массив событий активности за указанную дату.
     * @param {string|Date} date - Целевая дата.
     * @returns {Promise<Array>} Массив объектов ActivityEvent.
     */
    static async getDailyLog(date) {... }

    /**
     * Извлекает контекстную информацию для конкретного проекта.
     * @param {string} projectName - Имя проекта (WikiLink).
     */
    static async getProjectContext(projectName) {... }
}

3.2. Модуль B: Semantic Visualization Engine (Движок семантической визуализации)
Имя файла: mnemosyne_renderer.js
Этот модуль отвечает за преобразование структурированных данных в визуальные компоненты DOM. Он реализует стратегию "Context Layer Cake", визуализируя четыре слоя контекста: визуальный, текстовый, поведенческий и хронологический.1
Функциональные обязанности:
    1. Рендеринг Timeline (Mermaid): Генерация кода диаграммы Ганта на основе временных меток событий. Алгоритм должен группировать короткие события (менее 1 минуты) в кластеры "Micro-tasks", чтобы избежать визуального шума.9
    2. Генерация карточек контекста (Context Cards): Создание HTML-элементов для каждого значимого события. Карточка должна объединять скриншот (если есть), распознанный текст (OCR/Accessibility) и выведенное ИИ намерение (Intent).
    3. Тепловая карта интенсивности: Визуализация метрик ввода (нажатия клавиш, движения мыши) через цветовое кодирование (от синего к красному), позволяя мгновенно идентифицировать периоды "Глубокой работы" (Deep Work).2
Техническая реализация Mermaid:
Скрипт должен формировать строку в формате Mermaid динамически:

JavaScript


// Пример генерации строки Mermaid
let mermaidGraph = "gantt\n    title Activity Timeline\n    dateFormat HH:mm\n    axisFormat %H:%M\n";
// Цикл по событиям для добавления секций
events.forEach(e => {
    mermaidGraph += `    section ${e.appName}\n    ${e.intent} :${e.startTime}, ${e.duration}m\n`;
});
// Рендеринг через Dataview
dv.paragraph("```mermaid\n" + mermaidGraph + "\n```");

Этот подход позволяет создавать интерактивные графики без хранения их как изображений.14
3.3. Модуль C: Interactive Feedback Controller (Контроллер обратной связи)
Имя файла: mnemosyne_interact.js
Данный модуль реализует ключевую инновацию проекта — "Local Golden Dataset". Он превращает пассивный отчет в интерфейс для обучения ИИ. Поскольку модели (VLM/LLM) могут "галлюцинировать" или неверно интерпретировать контекст, пользователь должен иметь возможность корректировать их выводы.1
Функциональные обязанности:
    1. Интерфейс маркировки (Flagging UI): Внедрение кнопок "Flag Error" и "Correct" в каждую карточку события. Использование dv.el('button') для создания нативных элементов управления.16
    2. Обработка ввода пользователя: При нажатии кнопки "Correct" вызов модального окна (используя Obsidian.Modal), где пользователь может ввести правильное описание действия.
    3. Транзакционная запись: Безопасное обновление метаданных исходного файла лога. Использование app.fileManager.processFrontMatter гарантирует, что файл не будет поврежден при одновременной записи.17
    4. Управление обучающей выборкой: При подтверждении коррекции, скрипт должен инициировать перемещение связанного скриншота и метаданных в специальную директорию Mnemosyne/Training для последующего дообучения модели (Fine-Tuning).18
Схема данных обратной связи:
При коррекции во Frontmatter заметки добавляются поля:
    • human_verified: true
    • correction_text: "Actual user intent description"
    • training_status: "pending_lora"
3.4. Модуль D: Master Orchestrator (Главный оркестратор)
Имя файла: mnemosyne_dashboard.js
Это точка входа для пользователя. Скрипт, который вызывает остальные модули и управляет общим макетом (Layout) Dashboard.
Функциональные обязанности:
    1. Инициализация: Определение текущего контекста (открыт ли скрипт в Daily Note или в отдельном Dashboard).
    2. Маршрутизация: Выбор режима отображения (summary, timeline, debug) на основе переданных параметров.
    3. Обработка ошибок: Глобальный перехват исключений (try-catch), чтобы предотвратить "падение" всего рендера Dataview при ошибке в данных одной записи. Вывод информативных сообщений об ошибках (dv.paragraph("⚠️ Data Error:...")).
4. План реализации и спецификация кода (Implementation Plan)
Реализация разделена на три фазы, от базового отображения до полной интерактивности.
Фаза 1: "The Skeleton" (Базовая визуализация)
Цель: Обеспечить чтение и отображение данных, генерируемых "Watcher" (Tier 1) и "Brain" (Tier 2), в виде простой таблицы и списка.
Код 1.1: Data Ingestion (mnemosyne_data_connector.js)
Этот код должен уметь читать Frontmatter из множества файлов.

JavaScript


class MnemosyneData {
    static getFilesForDate(dv, dateString) {
        // Использование Dataview API для быстрого поиска по индексу
        return dv.pages('"Mnemosyne/Logs"')
           .where(p => p.file.name.includes(dateString))
           .sort(p => p.file.ctime, 'asc');
    }
}

Инсайт: Использование индекса Dataview (dv.pages) вместо прямого сканирования файловой системы (app.vault.getFiles) критически важно для производительности при росте количества логов, так как индекс уже находится в оперативной памяти.2
Код 1.2: Simple List Renderer (view_daily_simple.js)
Скрипт для Daily Note:
    • Получает данные через Connector.
    • Использует dv.table для вывода колонок: Time, App, Window Title, Input Intensity.
    • Это позволяет проверить целостность данных перед созданием сложной визуализации.
Фаза 2: "The Brain View" (Семантическая интеграция)
Цель: Визуализация намерений (Intents), распознанных ИИ, и связывание их с графом знаний.
Код 2.1: Smart Linking (Автоматическое связывание)
В модуле рендеринга необходимо реализовать функцию, которая сканирует текст intent_summary на наличие упоминаний существующих заметок.
    • Логика:
        1. Получить список всех имен файлов в хранилище (кэшированный).
        2. Использовать регулярные выражения для поиска совпадений в тексте Intent.
        3. Оборачивать совпадения в ].
    • Результат: Текст "User worked on Project Alpha documentation" автоматически превращается в "User worked on [[Project Alpha]] documentation", интегрируя лог в граф знаний.1
Код 2.2: Timeline Generator (mnemosyne_renderer.js)
Реализация функции renderTimeline.
    • Проблема: Mermaid диаграммы могут стать нечитаемыми при большом количестве событий.
    • Решение: Алгоритмическая агрегация. Перед генерацией Mermaid-кода, скрипт должен объединить последовательные события с одинаковым app_name в один блок, суммируя длительность.
    • Визуализация: Использование разных цветов для разных категорий приложений (IDE — синий, Браузер — оранжевый, Мессенджеры — зеленый) через CSS-классы Mermaid.
Фаза 3: "The Teacher" (Интерактивность и Обучение)
Цель: Замыкание цикла обратной связи.
Код 3.1: Feedback Button Logic (mnemosyne_interact.js)
Реализация кнопок управления внутри таблицы Dataview.
    • Техника: DataviewJS позволяет вставлять HTML.
JavaScript
const btn = dv.el("button", "Flag Error");
btn.onclick = async () => {
    // Логика обработки клика
    await InteractionHandler.flagEntry(filePath);
};

    • Важный нюанс: После изменения файла через app.vault.modify, Dataview автоматически обновит представление. Скрипт должен быть идемпотентным (безопасным для повторного выполнения), чтобы не дублировать элементы при перерисовке.19
Код 3.2: Перемещение данных для обучения
Функция moveToTrainingSet(file).
    • Использует app.fileManager.renameFile для перемещения скриншота из папки Inbox в Training/Dataset.
    • Это действие сигнализирует Python-компоненту (Tier 2) о том, что данный пример верифицирован человеком и должен быть использован при следующем цикле дообучения (Fine-Tuning).12
5. Интеграция данных и безопасность (Data Integrity & Security)
5.1. Санитизация PII на лету
Хотя "Brain" (Tier 2) должен очищать логи от конфиденциальной информации (PII), уровень представления (Tier 3) обязан реализовывать "Defense in Depth" (эшелонированную защиту).
    • Решение: В модуле mnemosyne_renderer.js должна быть внедрена функция sanitizeDisplay(text), которая выполняется непосредственно перед выводом текста в DOM.
    • Реализация: Использование Regex для маскировки паттернов кредитных карт, email-адресов и API-ключей (например, sk-...). Это защищает пользователя в ситуациях демонстрации экрана или совместной работы.1
5.2. Защита SSD через буферизацию рендеринга
Частые запросы к файловой системе могут создавать нагрузку.
    • Стратегия: Использовать dv.io.load (асинхронное чтение) только при необходимости отображения детального контента (например, при раскрытии "аккордеона" детализации события), а для общего списка использовать только метаданные из индекса Dataview, который уже находится в памяти.7
6. Детальная спецификация модулей и функций
В данном разделе приводится конкретное описание того, что должен делать каждый модуль кода.
6.1. Scripts/Mnemosyne/mnemosyne_core.js (Библиотека ядра)
Этот файл загружается во все вью.
Функция / Метод	Описание и Логика
getHighLevelSummary(date)	Агрегирует данные за день: общее время, топ-3 приложения, "Focus Score" (на основе интенсивности ввода). Возвращает объект JSON для рендеринга "шапки" дашборда.
redactPII(text)	Применяет набор Regex-правил для удаления чувствительных данных из отображаемого текста. Должна вызываться для всех строковых данных перед рендерингом.
formatDuration(ms)	Утилита для преобразования миллисекунд в человеко-читаемый формат ("2ч 15м").
6.2. Scripts/Mnemosyne/views/daily_dashboard.js (Вью Дашборда)
Скрипт, вызываемый в Daily Note.
    • Инициализация: Проверяет наличие папки с логами за текущую дату. Если логов нет, выводит "No Activity Recorded" (вместо ошибки).
    • Секция "Deep Work Timeline": Вызывает mnemosyne_renderer.js для отрисовки диаграммы Ганта, фильтруя только события с высокой интенсивностью ввода (Layer 3).
    • Секция "Activity Stream": Рендерит список карточек событий в обратном хронологическом порядке.
        ◦ Для каждой карточки вызывает проверку наличия скриншота.
        ◦ Если скриншот есть -> рендерит миниатюру с ссылкой на полный размер.
        ◦ Если скриншота нет -> рендерит плейсхолдер с иконкой приложения.
6.3. Scripts/Mnemosyne/actions/flag_entry.js (Экшен Флагирования)
Скрипт для обработки нажатия кнопки "Flag".
    • Вход: Путь к файлу лога (filePath).
    • Логика:
        1. Читает файл: const content = await app.vault.read(file).
        2. Парсит Frontmatter.
        3. Меняет статус: frontmatter.flagged = true.
        4. Записывает изменения.
        5. Вызывает new Notice("Entry flagged for retraining") для уведомления пользователя.
        6. (Опционально) Обновляет UI кнопки на "Flagged", изменяя её стиль (CSS class), чтобы показать состояние без полной перезагрузки страницы.20
7. Заключение
Предложенная архитектура Tier 3 обеспечивает создание надежного, производительного и безопасного интерфейса для системы Mnemosyne Core. Использование модульного подхода с dv.view() позволяет отделить логику представления от данных, а использование нативных API Obsidian (app.vault, app.fileManager) гарантирует бесшовную интеграцию в "Второй мозг" пользователя.
Реализация интерактивных элементов (кнопки, модальные окна) трансформирует систему из пассивного регистратора в активный инструмент обучения, что критически важно для улучшения качества работы ИИ-модели в долгосрочной перспективе. Данный план полностью соответствует требованиям технического задания и ограничениям аппаратной платформы.
