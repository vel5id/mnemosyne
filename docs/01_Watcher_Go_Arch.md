Архитектурная спецификация реализации Mnemosyne Core V3.0: Подсистема сбора данных и управления состоянием (Tier 1: The Watcher)
1. Стратегический контекст и операционная парадигма
1.1. Концепция Локального Цифрового Двойника
Проект Mnemosyne Core представляет собой радикальный отход от традиционных методов мониторинга активности, переходя от парадигмы пассивного логгера к концепции Локального Цифрового Двойника (Local Digital Twin). В основе этой концепции лежит создание автономной, локальной и приватно-ориентированной системы, способной реконструировать контекст работы пользователя с высокой точностью. Согласно утвержденному техническому плану, система отказывается от «грубой силы» (brute-force) непрерывного видеоанализа, характерного для версии V2.0, в пользу событийно-ориентированной полиглот-архитектуры (Event-Driven Polyglot Architecture).1
Этот сдвиг продиктован не только соображениями производительности, но и фундаментальной философией проекта: переход от вероятностных моделей (попытка ИИ угадать, что происходит на видео) к детерминированным сигналам (системные вызовы, точно сообщающие, что происходит). В этой иерархии Уровень 1 (Tier 1), получивший название The Watcher («Наблюдатель»), выполняет роль автономной нервной системы. Его задача — не «думать» (это задача Уровня 2), а «чувствовать» и «рефлексировать» с минимальной задержкой.1
1.2. Обоснование выбора стека технологий (Go vs. Python/Rust)
Выбор языка программирования Go (Golang) для реализации Уровня 1 является результатом строгого сравнительного анализа и директивы внутреннего технического директора (Internal CTO).1
Анализ альтернатив показал следующее:
    • Python: Отвергнут из-за наличия Global Interpreter Lock (GIL), который делает невозможным истинный параллелизм и вносит непредсказуемый джиттер (latency jitter) в высокочастотные циклы опроса. Бенчмарки показывают, что в задачах высокочастотного лупинга Go превосходит Python в среднем в 12 раз (21 мс против 272 мс на итерацию).1 Для системы, которая должна работать с частотой 5 Гц и потреблять ~0% CPU, Python непригоден.
    • Rust: Рассматривался внешними аудиторами как наиболее производительное решение (используется в аналогах типа Screenpipe).1 Однако, выбор был сделан в пользу Go из-за баланса между производительностью (достаточной для задачи) и скоростью разработки/поддержки командой. Go предоставляет встроенный сборщик мусора (Garbage Collector), оптимизированный для низкой латентности, и мощные инструменты для работы с системными вызовами (syscall), что критично для Win32 API.1
1.3. Аппаратные и архитектурные ограничения
Разработка ведется под конкретный профиль оборудования: NVIDIA RTX 5060 Ti и 80 ГБ оперативной памяти.1 Однако, для фонового агента Уровня 1 установлены жесткие лимиты, не зависящие от мощности хоста, чтобы гарантировать «невидимость» процесса:
    1. RAM: Строго менее 20 МБ. Это требует тщательного управления памятью, отказа от лишних аллокаций и использования пулов объектов.1
    2. CPU: Эффективно 0%. Процесс не должен появляться в топе диспетчера задач даже на старых машинах.1
    3. SSD: Запрет на прямую запись событий (Write Amplification). Обязательное использование буферизации в RAM.1
2. Архитектура программного решения (Go Implementation Architecture)
Реализация mnemosyne-watcher.exe должна следовать принципам модульности, где каждый пакет отвечает за изолированную область ответственности. Это критично для тестируемости и поддержки кода, работающего с небезопасными (unsafe) системными вызовами.
2.1. Структура пакетов (Package Layout)
Предлагаемая иерархия пакетов для обеспечения чистоты архитектуры:
Пакет	Путь	Назначение и Ответственность
Main	/cmd/watcher/main.go	Точка входа. Инициализация конфигурации, запуск горутин, перехват OS сигналов (SIGTERM).
Win32 API	/internal/win32	Низкоуровневые обертки над syscall. Загрузка DLL (user32, kernel32, shell32). Преобразование типов Go <-> C.
Monitor	/internal/monitor	Основной цикл опроса (Ticker Loop). Оркестрация сбора данных.
Sensors	/internal/sensors	Логика извлечения конкретных метрик: фокус окна, активность ввода, геометрия.
Heuristics	/internal/heuristics	Анализ состояния: детекция игр (Game Mode), расчет интенсивности ввода.
Buffer	/internal/buffer	Управление оперативной памятью. Реализация кольцевого буфера или слайса структур. Thread-safety.
Storage	/internal/storage	Взаимодействие с SQLite. Управление транзакциями, WAL-режимом и сбросом данных.
Models	/pkg/models	Общие структуры данных (LogEntry, Context), используемые всеми модулями.
2.2. Поток данных (Data Flow Pipeline)
Архитектура описывает линейный, но асинхронный поток данных:
    1. Perception (Восприятие): Цикл 5 Гц опрашивает Win32 API.
    2. Filter (Фильтрация): Данные проверяются на изменения (дедупликация) и значимость (игнорирование микро-движений мыши).
    3. Enrichment (Обогащение): Добавление временных меток, вычисление дельты ввода.
    4. Buffering (Буферизация): Сохранение в RAM-структуру.
    5. Persistence (Сохранение): Периодический сброс (Flush) в SQLite WAL.
3. Детальная спецификация модулей и реализация
3.1. Модуль /internal/win32: Фундамент системного взаимодействия
Этот модуль является единственным местом в программе, где разрешено использование пакета unsafe. Он инкапсулирует сложность взаимодействия с Windows API, предоставляя остальной программе безопасные Go-интерфейсы.
Техническая реализация
Вместо использования CGO, который усложняет сборку и может вносить накладные расходы при переключении контекста, необходимо использовать нативный пакет syscall или golang.org/x/sys/windows. Рекомендуется паттерн NewLazyDLL для отложенной загрузки библиотек, что ускоряет холодный старт приложения.2
Ключевые системные вызовы и их сигнатуры:
    1. GetForegroundWindow (user32.dll)
        ◦ Роль: Определение активного контекста пользователя.
        ◦ Go-сигнатура: func GetForegroundWindow() (syscall.Handle, error)
        ◦ Нюансы: Может возвращать 0 (NULL), если, например, пользователь заблокировал рабочую станцию или идет переключение контекста. Обработка ошибки должна отличать системный сбой от штатного отсутствия окна.4
    2. GetWindowThreadProcessId (user32.dll)
        ◦ Роль: Связывание визуального окна с исполняемым процессом.
        ◦ Go-сигнатура: func GetWindowThreadProcessId(hwnd syscall.Handle, pid *uint32) (uint32, error)
        ◦ Логика: Возвращает ID потока как результат функции и ID процесса через указатель. Для Mnemosyne критически важен PID для фильтрации процессов.5
    3. GetWindowTextW (user32.dll)
        ◦ Роль: Извлечение семантического контекста (заголовка).
        ◦ Go-сигнатура: func GetWindowText(hwnd syscall.Handle, str *uint16, maxCount int32) (int32, error)
        ◦ Оптимизация памяти: Для соблюдения лимита 20 МБ RAM критически важно не аллоцировать новый буфер на каждой итерации. Необходимо использовать sync.Pool или предварительно выделенный буфер uint16 внутри воркера мониторинга. Преобразование syscall.UTF16ToString должно происходить только в момент фиксации изменения заголовка.6
    4. GetLastInputInfo (user32.dll)
        ◦ Роль: Расчет метрики "Input Intensity" и детекция простоя.
        ◦ Go-сигнатура: Требует структуру LASTINPUTINFO.
        ◦ Важность: Позволяет отличить "чтение" (низкая активность) от "работы" (высокая активность) без использования глобальных хуков, которые могут быть расценены антивирусами как кейлоггеры.8
    5. SHQueryUserNotificationState (shell32.dll)
        ◦ Роль: Эвристика "Smart Full Stop" (Режим «Не беспокоить» / Игра).
        ◦ Значения: Возвращает enum. Критические значения: QUNS_RUNNING_D3D_FULL_SCREEN (значение 3) и QUNS_BUSY (значение 2). Это самый надежный способ определить запущенную игру без анализа GPU.10
3.2. Модуль /internal/monitor: Цикл Наблюдения (The 5Hz Loop)
Этот модуль реализует бесконечный цикл, который управляет частотой опроса.
Реализация Ticker Loop
Использование time.Sleep недопустимо, так как оно вносит дрейф (drift) времени выполнения. Необходимо использовать time.Ticker, который гарантирует стабильную частоту запуска.

Go


// Псевдокод архитектуры цикла
func (w *Watcher) Start(ctx context.Context) {
    ticker := time.NewTicker(200 * time.Millisecond) // 5Hz = 200ms
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            w.Flush() // Грациозное завершение
            return
        case <-ticker.C:
            w.tick()
        }
    }
}

Логика функции tick()
Каждая итерация должна укладываться в бюджет времени (менее 10 мс на обработку), чтобы не нагружать CPU.
    1. Gaming Guard (Первый эшелон защиты):
        ◦ Вызов SHQueryUserNotificationState. Если результат QUNS_RUNNING_D3D_FULL_SCREEN, цикл прерывается немедленно (return). Это реализует требование "Smart Full Stop".1
        ◦ Дополнительная эвристика: Проверка GetForegroundWindow -> GetWindowRect. Если размер окна совпадает с разрешением экрана (например, 1920x1080) и отсутствуют стандартные стили рамок (borderless), это усиливает сигнал о полноэкранном приложении.12
    2. Idle Check:
        ◦ Вызов GetLastInputInfo. Сравнение GetTickCount() - LastInputTick.
        ◦ Если разница > 60 секунд (настраиваемо), система переходит в режим "Idle". В этом режиме частота записи в буфер может быть снижена, или запись может помечаться флагом is_idle=true.8
    3. Сбор метаданных:
        ◦ Получение HWND. Сравнение с предыдущим сохраненным HWND.
        ◦ Оптимизация: Если HWND и Заголовок Окна не изменились с прошлой итерации (200 мс назад) и активность ввода низкая, запись не создается или просто обновляется счетчик длительности (duration) последнего события в буфере. Это существенно экономит место в буфере и БД.
    4. Расчет Input Intensity:
        ◦ Вместо кейлоггинга (счетчика нажатий), который требует хуков (SetWindowsHookEx) и вызывает лаги, используется производная от GetLastInputInfo. Если LastInputTick изменился по сравнению с прошлым замером, значит было действие. Частота изменений этого тика за секунду дает приблизительную "скорость" ввода без нарушения приватности.14
3.3. Модуль /internal/buffer: Стратегия Buffered Persistence
Этот модуль отвечает за реализацию требования защиты SSD.1
Структура данных
Используется слайс структур (Slice of Structs), предварительно аллоцированный на старте программы, чтобы избежать нагрузки на GC.

Go


type LogEntry struct {
    Timestamp     int64
    ProcessName   string // интернированная строка для экономии памяти
    WindowTitle   string
    WindowHandle  uintptr
    InputScore    float32
}

const BufferCapacity = 1000 // ~3-5 минут данных
var buffer = make(LogEntry, 0, BufferCapacity)

Политика сброса (Flush Policy)
Сброс данных из RAM на диск происходит при выполнении одного из условий (OR):
    1. Capacity Threshold: Буфер заполнен (например, len(buffer) >= 500).
    2. Time Threshold: Прошло 5 минут с последнего сброса (для предотвращения потери данных при сбоях питания).
    3. Signal Trap: Получен сигнал завершения работы ОС.1
3.4. Модуль /internal/storage: SQLite и WAL
Этот модуль управляет сохранением данных. Критически важно правильное конфигурирование SQLite для работы в высоконагруженном режиме записи (Write-Intensive) параллельно с чтением (Read-Intensive) со стороны Python-модуля.
Конфигурация соединения (DSN)
Драйвер mattn/go-sqlite3 должен быть инициализирован со следующими PRAGMA 1:

SQL


PRAGMA journal_mode = WAL;       -- Позволяет одновременное чтение и запись (Writer не блокирует Reader)
PRAGMA synchronous = NORMAL;     -- Защита SSD. Сбрасывает данные на диск реже, полагаясь на кэш ОС.
PRAGMA temp_store = MEMORY;      -- Хранит временные таблицы в RAM (используя доступные 80 ГБ).
PRAGMA busy_timeout = 5000;      -- Ждет 5 секунд при блокировке, прежде чем вернуть ошибку.

Анализ synchronous = NORMAL: В режиме WAL, установка synchronous = NORMAL означает, что транзакция считается завершенной, когда она записана в кэш файловой системы, но не обязательно на физический диск (fsync вызывается только при checkpoint). Это снижает количество операций ввода-вывода (IOPS) на порядки, защищая NVMe от износа. Риск потери данных существует только при внезапном отключении питания, но не при крахе приложения (OS kernel защищает кэш).19
Реализация транзакций (Batch Insert)
Прямая вставка (db.Exec) каждой записи убьет производительность (скорость ~50 записей/сек). Необходима групповая вставка внутри одной транзакции:

Go


func Flush(entriesLogEntry) {
    tx, _ := db.Begin()
    stmt, _ := tx.Prepare("INSERT INTO logs (...) VALUES (...)")
    for _, entry := range entries {
        stmt.Exec(...)
    }
    tx.Commit()
}

Это позволяет достичь скорости вставки 50,000+ записей в секунду, делая операцию сброса буфера практически мгновенной.20
4. Сценарий Грациозного Завершения (Graceful Shutdown)
Учитывая стратегию буферизации, принудительное убийство процесса (Task Kill) приведет к потере 5-10 минут данных. Необходимо реализовать перехват сигналов ОС.
Техническая реализация
В Go это реализуется через канал os.Signal.

Go


// cmd/watcher/main.go
func main() {
    //... инициализация...
    
    stop := make(chan os.Signal, 1)
    signal.Notify(stop, os.Interrupt, syscall.SIGTERM) // Перехват Ctrl+C и завершения docker/systemd

    <-stop // Блокировка до получения сигнала

    logger.Info("Shutdown signal received. Flushing buffer...")
    bufferMonitor.ForceFlush() // Синхронный сброс остатка данных
    db.Close()
    logger.Info("Cleanup complete. Exiting.")
}

Этот механизм гарантирует, что даже при перезагрузке Windows или обновлении приложения, накопленные данные будут сброшены на диск перед выходом.16
5. Анализ рисков и критических путей
5.1. Утечки памяти в цикле
Риск: Функция GetWindowText может создавать новые строки (string allocation) 5 раз в секунду. В Go строки неизменяемы, что создает нагрузку на GC.
Митигация: Использование байтовых буферов и сравнение хешей или байтовых массивов заголовков перед конвертацией в строку. Строка создается только если заголовок действительно изменился.
5.2. Блокировки базы данных (SQLITE_BUSY)
Риск: Если Python-скрипт («Мозг») начнет тяжелую выборку данных для анализа, он может заблокировать WAL-файл для checkpoint'а.
Митигация: Использование busy_timeout в 5000 мс позволяет Go-скрипту ждать освобождения ресурса. В крайнем случае, если таймаут превышен, буфер просто продолжает накапливать данные до следующей попытки сброса (увеличение буфера вместо потери данных).17
5.3. Сбои GetForegroundWindow
Риск: API может вернуть невалидный хендл или зависнуть, если целевое приложение (например, игра с анти-читом) блокирует доступ.
Митигация: Обертывание вызовов API в структуру с таймаутом (хотя для Win32 syscall это сложно) или, что более реалистично, строгая валидация возвращаемых значений. Если GetForegroundWindow возвращает 0, система записывает специальное событие "System/Unknown" вместо краха.4
6. Выводы и Рекомендации по развертыванию
Данный план реализации полностью удовлетворяет жестким требованиям Internal CTO:
    1. Ресурсы: Использование Go и ручного управления буферами обеспечивает потребление <20MB RAM.
    2. SSD: Стратегия Buffered Persistence + synchronous=NORMAL снижает износ диска в ~60 раз по сравнению с прямой записью.
    3. Игровой опыт: Детекция через SHQueryUserNotificationState гарантирует отсутствие микро-фризов.
    4. Архитектура: Четкое разделение на модули (win32, monitor, storage) обеспечивает поддерживаемость кода.
Следующие шаги для команды разработки:
    1. Создать репозиторий с указанной структурой пакетов.
    2. Написать unit-тесты для модуля buffer (проверка логики сброса).
    3. Реализовать прототип модуля win32 и проверить корректность работы с Unicode-заголовками (кириллица/эмодзи).
    4. Провести нагрузочное тестирование с открытым SQLite соединением в Python-скрипте, чтобы верифицировать настройки WAL.
Этот документ является окончательным руководством к действию для реализации Уровня 1 системы Mnemosyne Core.
Сводная таблица технических решений

Параметр	Решение	Обоснование	Источник
Язык	Go 1.22+	Отсутствие GIL, скорость, типизация	1
API Интерфейс	syscall / LazyDLL	Минимизация оверхеда CGO, нативность	2
Polling Rate	5Hz (200ms)	Баланс между точностью и нагрузкой	1
БД Режим	WAL + Normal Sync	Конкурентность и защита SSD	19
Детекция Игр	SHQueryUserNotificationState	Нативный API, без инъекций	10
Idle Detector	GetLastInputInfo	Без глобальных хуков (anti-keylogger safe)	8
Сброс буфера	500 записей / 5 мин	Защита от Write Amplification	1
