Архитектурная Спецификация Mnemosyne Core V3.0: Реализация Локального Цифрового Двойника на Базе Полиглотической Среды и SQL
1. Введение и Стратегический Контекст
1.1. Эволюция Парадигмы: От Регистрации Событий к Цифровому Двойнику
Проект Mnemosyne Core знаменует собой фундаментальный отказ от традиционных моделей агрегации данных, опирающихся на облачные вычисления и SaaS-инфраструктуру. В условиях нарастающей эрозии цифровой приватности и коммодитизации пользовательских данных, архитектура V3.0 постулирует концепцию «Локального Цифрового Двойника» (Local Digital Twin).1 В отличие от пассивных регистраторов активности или утилит захвата экрана, Mnemosyne Core проектируется как автономная интеллектуальная система, чья задача — не просто фиксировать пиксели и нажатия клавиш, но интерпретировать семантический смысл действий пользователя, формируя так называемый «цифровой выхлоп» (digital exhaust) в структурированный граф знаний.
Стратегическое видение, утвержденное внутренним техническим директором (CTO), требует перехода от ресурсоемкого непрерывного видеоанализа, характерного для версии V2.0, к событийно-ориентированной полиглотической архитектуре (Event-Driven Polyglot Architecture).1 Этот сдвиг обусловлен необходимостью балансировать между глубиной семантического понимания контекста и жесткими ограничениями потребительского оборудования высокого класса, в частности видеокарты NVIDIA RTX 5060 Ti и 80 ГБ оперативной памяти. Ключевым императивом становится принцип суверенитета данных: все вычисления, хранение и инференс моделей искусственного интеллекта должны выполняться строго локально, исключая любые формы внешней телеметрии или API-зависимостей, что гарантирует абсолютную защиту персональной идентифицируемой информации (PII).1
1.2. Аппаратные Ограничения как Драйвер Архитектуры
Анализ аппаратной платформы выявил критические узкие места, которые сформировали архитектурный облик системы. Видеокарта RTX 5060 Ti, несмотря на достаточную вычислительную мощность для инференса, ограничена 128-битной шиной памяти. Это физическое ограничение делает невозможным эффективную динамическую смену моделей (Model Swapping) в реальном времени, так как пересылка весов моделей объемом 6-8 ГБ вызывает неприемлемые задержки и блокирует шину PCIe.1 Следовательно, архитектура должна минимизировать использование GPU, резервируя его исключительно для пакетной обработки высокоуровневых семантических задач, и переложить основную нагрузку по сбору и предварительной обработке данных на центральный процессор (CPU) и оперативную память (RAM). Наличие 80 ГБ RAM рассматривается не как пассивный ресурс, а как стратегический буфер, позволяющий компенсировать ограничения дисковой подсистемы и видеопамяти путем агрессивного кэширования и использования in-memory баз данных для промежуточных вычислений.1
2. Глобальная Архитектура: Трехуровневая Полиглотическая Модель
Реализация системы базируется на строгом разделении ответственности между тремя технологическими стеками, каждый из которых выбран для решения специфического класса задач с максимальной эффективностью. Эта структура, определенная как «Полиглотическая архитектура V3.0» 1, позволяет обойти ограничения отдельных языков программирования, таких как Global Interpreter Lock (GIL) в Python или сложность управления памятью в низкоуровневых языках.
2.1. Tier 1: The Watcher (Наблюдатель) — Go (Golang)
Уровень "Наблюдателя" функционирует как автономная нервная система цифрового двойника. Его задача — непрерывный, высокочастотный мониторинг состояния операционной системы с минимальным влиянием на производительность хоста. Выбор языка Go обусловлен его способностью компилироваться в эффективный машинный код, наличием сборщика мусора, оптимизированного для низкой латентности, и превосходной поддержкой конкурентности через горутины (goroutines).1 В отличие от Python, Go позволяет реализовать цикл опроса с частотой 5 Гц (каждые 200 мс) при потреблении CPU менее 0.1% и использовании памяти в пределах 20 МБ, что является жестким требованием CTO.1 На этом уровне происходит взаимодействие с Win32 API для захвата «дешевых» метаданных: дескрипторов окон (HWND), названий процессов и координат областей интереса (ROI).
2.2. Tier 2: The Brain (Мозг) — Python 3.10+
Уровень "Мозга" берет на себя роль когнитивной коры. Он работает асинхронно, в отрыве от реального времени, обрабатывая накопленные данные пакетами (batches). Выбор Python безальтернативен ввиду его доминирования в экосистеме машинного обучения (PyTorch, HuggingFace).1 Задачи этого уровня включают тяжелые вычисления: оптическое распознавание символов (OCR), визуальный анализ сцены с помощью мультимодальных моделей (VLM), санитизацию данных (удаление PII) и инференс намерений пользователя с помощью больших языковых моделей (LLM). Архитектура этого уровня спроектирована с учетом "VRAM Guard" — механизма, предотвращающего конфликт за ресурсы видеокарты с пользовательскими приложениями.
2.3. Tier 3: The View (Представление) — Obsidian / JavaScript
Уровень "Представления" интегрирует результаты работы системы непосредственно в рабочий процесс пользователя, используя платформу Obsidian. Вместо создания отдельного интерфейса, Mnemosyne Core внедряет данные в существующую базу знаний ("Second Brain") через плагины DataviewJS и SQLite DB.3 Это обеспечивает бесшовный доступ к аналитике и позволяет пользователю взаимодействовать с цифровым двойником в привычной среде Markdown, используя мощные возможности визуализации графов знаний и полнотекстового поиска.
3. Стратегия Хранения Данных: SQL и Механизмы Конкурентности
Центральным связующим звеном полиглотической архитектуры выступает база данных SQLite. Выбор этой СУБД обусловлен её серверной природой (отсутствие необходимости администрировать отдельный процесс), возможностью работы в режиме «один файл — одна база» и мощными встроенными механизмами расширения, такими как FTS5 (Full-Text Search) и JSON1. Однако, специфика высокочастотной записи (из Go) и одновременного тяжелого чтения (из Python) требует нетривиальной конфигурации для обеспечения целостности и производительности.
3.1. Режим Write-Ahead Logging (WAL) как Основа Конкурентности
Традиционный режим журналирования SQLite (Rollback Journal) блокирует всю базу данных на чтение во время записи, что недопустимо для системы реального времени. Архитектура Mnemosyne Core императивно требует использования режима Write-Ahead Logging (WAL).4 В этом режиме изменения записываются не в основной файл базы данных, а в отдельный WAL-файл, что позволяет читателям (модулю Python) работать с консистентным снимком данных одновременно с тем, как писатель (модуль Go) добавляет новые транзакции. Это устраняет блокировки чтения-записи, обеспечивая высокую пропускную способность системы.4
Однако WAL не является "серебряной пулей" и имеет свои ограничения, главное из которых — наличие только одного активного писателя в любой момент времени.5 Попытка одновременной записи из нескольких потоков или процессов приведет к ошибке SQLITE_BUSY. Для решения этой проблемы архитектура строго регламентирует, что модуль Watcher (Go) является единственным компонентом с правом записи в таблицу сырых событий, в то время как модуль Brain (Python) пишет только в таблицы обогащенного контекста, и эти процессы разнесены во времени и логически.1
3.2. Защита SSD: Стратегия Buffered Persistence
Высокочастотный характер сбора данных (5 Гц) создает серьезную угрозу для долговечности NVMe SSD накопителей из-за явления, известного как Write Amplification (усиление записи). Каждая мелкая транзакция вызывает обновление метаданных файловой системы и стирание целых блоков флэш-памяти. Для минимизации этого эффекта архитектура вводит концепцию "Buffered Persistence" (Буферизированная Персистентность).1
Суть стратегии заключается в запрете на прямую запись каждого события на диск. Вместо этого, модуль Watcher накапливает данные в кольцевом буфере в оперативной памяти (RAM). Сброс данных на диск (Flush) происходит только при достижении критической массы (например, 500 записей) или по тайм-ауту (5 минут). Это позволяет агрегировать тысячи мелких операций в одну последовательную транзакцию записи, снижая количество циклов перезаписи ячеек SSD в десятки раз.1 Для поддержки этой стратегии база данных должна быть инициализирована со специфическими PRAGMA-настройками.
3.3. Конфигурация SQL-окружения
Для реализации описанных требований, скрипт инициализации базы данных должен содержать следующие директивы, которые являются обязательными для всех модулей системы:

Директива PRAGMA	Значение	Обоснование и Влияние на Архитектуру
journal_mode	WAL	Активирует режим Write-Ahead Logging. Позволяет Python-модулю читать исторические данные для анализа, пока Go-модуль продолжает буферизированную запись новых событий, не блокируя друг друга.4
synchronous	NORMAL	В режиме WAL эта настройка позволяет операционной системе буферизировать запись на диск, не дожидаясь физического завершения fsync для каждой транзакции. Это критически важно для защиты SSD, так как значительно снижает нагрузку на контроллер диска, сохраняя при этом приемлемый уровень надежности (риск потери данных только при внезапном отключении питания).6
temp_store	MEMORY	Принудительно хранит все временные таблицы и индексы в оперативной памяти. Учитывая наличие 80 ГБ RAM 1, это позволяет выполнять сложные аналитические запросы (JOIN, GROUP BY) без обращения к диску, ускоряя работу модуля Brain.
mmap_size	268435456	Включает Memory-Mapped I/O (отображение файла в память) размером 256 МБ. Это снижает количество системных вызовов read()/write(), так как SQLite работает с базой данных как с массивом байтов в памяти.7
busy_timeout	5000	Устанавливает время ожидания (5000 мс) при блокировке базы данных. Это предотвращает падение модулей с ошибкой database is locked при кратковременных коллизиях доступа.2
4. Схема Базы Данных и Логика Хранения
Архитектура данных Mnemosyne Core построена на принципе разделения «сырых» фактов и «синтезированного» контекста. Это позволяет хранить компактные метаданные вечно, а тяжелые семантические данные подвергать ротации или сжатию.
4.1. Таблица raw_events: Хроника Активности
Эта таблица является первичным приемником данных от модуля Watcher. Она спроектирована с учетом максимальной компактности, так как количество записей может достигать сотен тысяч в сутки.
DDL Схема:

SQL


CREATE TABLE IF NOT EXISTS raw_events (
    id INTEGER PRIMARY KEY AUTOINCREMENT,  -- Уникальный идентификатор события
    session_uuid TEXT NOT NULL,            -- ID сессии (от запуска до выключения Mnemosyne)
    timestamp_utc TEXT NOT NULL,           -- Время события в формате ISO8601 (для переносимости)
    unix_time INTEGER NOT NULL,            -- Время в Unix Epoch (для индексации и быстрого поиска)
    
    -- Tier 1 Metadata (Получено через Win32 API)
    process_name TEXT NOT NULL,            -- Имя исполняемого файла (напр., "chrome.exe")
    window_title TEXT,                     -- Заголовок окна (напр., "SQLite WAL optimization - Google Search")
    window_hwnd INTEGER NOT NULL,          -- Дескриптор окна (для идентификации уникальности окна)
    
    -- Region of Interest (ROI) - Координаты для VLM
    roi_left INTEGER,
    roi_top INTEGER,
    roi_right INTEGER,
    roi_bottom INTEGER,
    
    -- Input Telemetry (Поведенческий анализ)
    input_idle_ms INTEGER DEFAULT 0,       -- Время бездействия пользователя (мс)
    input_intensity REAL DEFAULT 0.0,      -- Вычисленный коэффициент активности ввода (0.0 - 1.0)
    
    -- System Flags
    is_processed BOOLEAN DEFAULT 0,        -- Флаг: обработано ли событие модулем Brain
    has_screenshot BOOLEAN DEFAULT 0,      -- Флаг: сохранен ли скриншот на диске
    screenshot_hash TEXT                   -- Хэш файла скриншота (для дедупликации)
);

-- Индексы для оптимизации
CREATE INDEX idx_raw_time ON raw_events(unix_time);
CREATE INDEX idx_raw_processed ON raw_events(is_processed) WHERE is_processed = 0; -- Частичный индекс для очереди обработки

Логика хранения:
    • Что записывать: Метаданные активного окна каждые 200 мс.
    • Откуда получать: Системные вызовы GetWindowThreadProcessId, GetWindowText, GetLastInputInfo.
    • Нюансы: Поле roi_* критически важно для модуля компьютерного зрения (Tier 4), так как позволяет VLM модели фокусироваться только на активном приложении, игнорируя фоновый шум рабочего стола.1
4.2. Таблица context_enrichment: Семантический Слой
Эта таблица заполняется модулем Brain и содержит результаты работы ресурсоемких алгоритмов. Связь с raw_events осуществляется по внешнему ключу.
DDL Схема:

SQL


CREATE TABLE IF NOT EXISTS context_enrichment (
    event_id INTEGER PRIMARY KEY,
    
    -- Textual Signals (Tier 2 & 3)
    accessibility_tree_json TEXT,          -- Полный дамп структуры UI (кнопки, поля ввода)
    ocr_content TEXT,                      -- Текст, извлеченный via OCR (Tesseract/EasyOCR)
    
    -- Semantic Analysis (Tier 4 - AI)
    vlm_description TEXT,                  -- Описание визуальной сцены от MiniCPM-V
    user_intent TEXT,                      -- Интерпретация намерения пользователя (LLM)
    
    -- Knowledge Graph Integration
    generated_wikilinks TEXT,              -- JSON массив ссылок (напр., ["[[Project Alpha]]"])
    generated_tags TEXT,                   -- JSON массив тегов (напр., ["#research", "#urgent"])
    
    FOREIGN KEY(event_id) REFERENCES raw_events(id) ON DELETE CASCADE
);

Логика хранения:
    • Что записывать: Очищенный от PII текст, структурные данные UI, семантические выводы.
    • Откуда получать: Результаты инференса нейросетей, UI Automation API.
    • Нюансы: Поле accessibility_tree_json является предпочтительным источником текстовых данных, так как извлечение через Win32 UI Automation происходит быстрее и точнее, чем OCR.1
4.3. Виртуальная Таблица fts_search: Полнотекстовый Поиск
Вместо использования тяжеловесных векторных баз данных (как ChromaDB), которые требуют гигабайты оперативной памяти для хранения индексов, архитектура использует встроенный в SQLite модуль FTS5.1 Это решение идеально подходит для локального поиска ("Full-Text Search") и потребляет минимум ресурсов.
DDL Схема:

SQL


CREATE VIRTUAL TABLE fts_search USING fts5(
    window_title,
    ocr_content,
    vlm_description,
    user_intent,
    content='context_enrichment',  -- External Content Table (экономия места)
    content_rowid='event_id'
);

-- Триггеры для автоматической синхронизации
CREATE TRIGGER trg_fts_insert AFTER INSERT ON context_enrichment BEGIN
  INSERT INTO fts_search(rowid, window_title, ocr_content, vlm_description, user_intent)
  SELECT new.event_id, 
         (SELECT window_title FROM raw_events WHERE id = new.event_id),
         new.ocr_content, 
         new.vlm_description, 
         new.user_intent;
END;

Инсайт: Использование content='context_enrichment' создает "Contentless" индекс, который не дублирует сами текстовые данные, а хранит только поисковые токены. Это снижает размер базы данных на 40-50% по сравнению с стандартным FTS индексом.8
5. План Реализации Модулей: Задачи и Алгоритмы
5.1. Модуль Watcher (Go): Управление Записью и Защита Ресурсов
Этот модуль является единственным "Писателем" (Writer) в системе. Его критическая задача — управление потоком записи в SQLite, чтобы не допустить блокировки базы данных.
Архитектура и Задачи:
    1. Event Loop (Цикл Событий): Реализация бесконечного цикла с использованием time.NewTicker(200 * time.Millisecond). Использование Go позволяет избежать оверхеда переключения контекста, характерного для Python.
    2. RAM Ring Buffer (Кольцевой Буфер): Создание структуры данных в памяти (Slice of Structs), способной хранить до 1500 событий.
    3. Логика "Smart Stop": Перед каждым циклом захвата модуль проверяет имя активного процесса по "Черному списку" (игры, тяжелые 3D приложения). Если обнаружена игра, захват приостанавливается (continue), чтобы не вызвать микро-фризы (stuttering) из-за системных прерываний.1
    4. Transaction Management:
        ◦ Использование драйвера mattn/go-sqlite3.
        ◦ Установка db.SetMaxOpenConns(1) для глобального объекта базы данных. Это гарантирует, что внутри самого приложения Go не возникнет конкуренции за запись.2
        ◦ Использование BEGIN IMMEDIATE TRANSACTION при сбросе буфера. Это мгновенно переводит соединение в режим записи, предотвращая ситуацию, когда два процесса пытаются повысить свои права с чтения на запись и вызывают взаимную блокировку (Deadlock).2
Алгоритм Сброса (Pseudocode):

Go


func FlushBuffer(db *sql.DB, bufferEvent) {
    tx, err := db.Begin() // Start Transaction
    if err!= nil { return } // Retry logic needed
    
    stmt, _ := tx.Prepare("INSERT INTO raw_events (...) VALUES (...)")
    for _, evt := range buffer {
        stmt.Exec(evt.Timestamp, evt.ProcessName,...)
    }
    
    tx.Commit() // Write to WAL
    buffer = nil // Clear buffer
}

5.2. Модуль Brain (Python): Семантический Анализ и VRAM Guard
Этот модуль функционирует как "Читатель" (Reader) и "Обогатитель". Он запускается периодически или работает демоном, отслеживая новые записи.
Архитектура и Задачи:
    1. Batch Ingestion (Пакетное Чтение): Выборка необработанных событий: SELECT * FROM raw_events WHERE is_processed = 0 LIMIT 100. Ограничение LIMIT важно для управления памятью и временем транзакции.
    2. VRAM Guard (Защита Видеопамяти): Перед запуском визуального анализа (VLM) скрипт обязан опросить драйвер GPU (через pynvml).
        ◦ Если Free Memory < 4GB (пользователь играет или рендерит), VLM пропускается, выполняется только текстовый анализ (Tier 2/3) на CPU.
        ◦ Это решает проблему узкой шины (128-bit), предотвращая постоянную загрузку/выгрузку моделей (Model Thrashing).1
    3. Context Layering (Наслоение Контекста):
        ◦ Layer 1: Извлечение текста из accessibility_tree (быстро, точно).
        ◦ Layer 2: Если Layer 1 пуст (например, RDP сессия или игра), запуск OCR (Tesseract).
        ◦ Layer 3: Запуск MiniCPM-V (Int4) только для событий с флагом has_screenshot = 1 и высокой значимостью (смена окна, долгая активность).
    4. PII Sanitization (Очистка Данных): Применение Regex-фильтров ко всем текстовым полям перед записью в context_enrichment. Паттерны включают: кредитные карты (алгоритм Луна), email-адреса, приватные ключи (sk-..., ghp_...).
    5. Intent Inference (Вывод Намерений): Формирование промпта для локальной LLM (Llama-3 8B), требующего вывода в формате Markdown с WikiLinks.
5.3. Модуль View (Obsidian): Визуализация и Граф Знаний
Интеграция с Obsidian реализуется через прямые SQL-запросы к локальной базе данных, минуя создание промежуточных Markdown-файлов для каждого события.
Архитектура и Задачи:
    1. Плагин SQLite: Использование плагина (например, sqlite-db или sqlseal 3), позволяющего выполнять запросы к файлу activity.db из среды Obsidian.
    2. DataviewJS Scripting: Написание JavaScript-кода внутри заметок для динамической генерации отчетов.
        ◦ Задача: Сформировать таблицу "Хроника Дня".
        ◦ Задача: Сгенерировать график активности (Input Intensity) по часам.
    3. Интеграция Графа: Поскольку модуль Brain генерирует WikiLinks (напр., [[Project X]]) в поле user_intent, рендеринг этого поля через DataviewJS автоматически делает ссылки активными. Это позволяет Obsidian включить внешние события в свой внутренний граф связей (Backlinks), создавая эффект "Цифрового Двойника", который "помнит", над чем работал пользователь.
6. Безопасность и Приватность
6.1. Шифрование Данных (SQLCipher)
Учитывая, что база данных содержит детальную хронику жизни пользователя, хранение её в открытом виде недопустимо. Рекомендуется использование SQLCipher — расширения SQLite, обеспечивающего прозрачное 256-битное AES шифрование всего файла базы данных.4
    • Реализация: Сборка драйверов go-sqlite3 и Python pysqlite3 с флагом SQLITE_HAS_CODEC.
    • Ключи: Ключ шифрования должен вводиться пользователем при старте сессии или храниться в защищенном хранилище ОС (Windows Credential Manager).
    • Влияние на WAL: SQLCipher поддерживает WAL, но требует, чтобы и .db, и .wal файлы были зашифрованы, что вносит небольшой оверхед в производительность (около 5-15%), который компенсируется мощностью современного CPU.4
6.2. Сетевая Изоляция (Air-Gap)
Архитектура Mnemosyne Core следует принципу "Local-Only". Для гарантии отсутствия утечек данных (exfiltration):
    • Бинарные файлы (mnemosyne.exe, python.exe виртуального окружения) должны быть заблокированы в Windows Firewall для любых исходящих соединений, кроме localhost (если используется локальный сервер инференса).
    • Это гарантирует, что даже в случае компрометации кода или "галлюцинации" модели, пытающейся отправить данные на внешний URL, физическая передача данных будет невозможна.
7. Заключение
Представленный архитектурный план Mnemosyne Core V3.0 демонстрирует реалистичный и технически обоснованный подход к созданию локального цифрового двойника. Отказ от монолитной архитектуры в пользу полиглотической системы (Go/Python/SQL/JS) позволяет эффективно утилизировать сильные стороны каждого инструмента: скорость Go для сбора данных, мощь экосистемы Python для AI и гибкость Obsidian для интерфейса.
Центральным элементом устойчивости системы является грамотная конфигурация SQLite в режиме WAL с буферизацией в оперативной памяти. Это решение нивелирует риски износа SSD и обеспечивает необходимую конкурентность процессов. Внедрение FTS5 вместо внешних векторных баз данных и строгая дисциплина управления VRAM (VRAM Guard) позволяют системе функционировать на потребительском оборудовании (RTX 5060 Ti), соблюдая баланс между производительностью и глубиной семантического анализа. Данная спецификация полностью удовлетворяет требованиям CTO по созданию автономной, приватной и интеллектуальной системы наблюдения.
